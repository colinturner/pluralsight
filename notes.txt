##Programming Style & Your Brain

There are two main drivers in decision-making: Head and Gut.

The head favours deliberate decisions, while the Gut prefers instinct. The Gut will provide estimated data to the Head, which then
comes up with an elaborate output based on that imperfect input.

JS has really good parts and really bad parts; very polarized language in that way.

Avoid confusing code: it's best to adopt practices that reduce ambiguity in the way your code could be interpreted. Most coding resources
go into debugging rather than the initial writing of the code. So write good code in the first place! Take the time for some extra
keystrokes - it'll pay off in the maintenance portion of the software lifecycle.

###JSLint
JSLint is a tool Crockford developed to help spot typos and small errors (e.g. forgetting a semi-colon).


##And Then There Was JavaScript

JavaScript was written in 10 days! It also underwent a period of 10 YEARS (1999-2009) without a major update. ES3 --> ES5; ES4 was scrapped altogether.

JS is an object-oriented language where almost everything is an object. Object literals are important. JS is a prototype-based language,
rather than a class-based language. This means that we can create object prototypes and then create new objects (e.g. with the "new" constructor) that
inherit properties from a given object prototype.

###Numbers
There is only one number-type in JS: 64-bit floating point, aka "Double".

JS does not have "int" when defining numbers --> Good because ints cause arithmetic errors.

Number literals: you can use decimal notation, scientific notation, etc.

Associative Law does not always hold in JS because computer numbers are necessarily finite (due to bit limitations), whereas real-world numbers are not always finite.

Associativity tends to hold in JS arithmetic for numbers under 9 quadrillion.

Decimal fractions are approximate in JS. This is a problem with binary computing (not JS-specific). JS *should* have used a decimal, floating-point format.

Number methods: numbers are objects, and so we can run methods on them (e.g. "toFixed", "toPrecision", "valueOf", "toExponential", "toLocaleString", "toString").
You can even add your own Number Methods to the Number object (e.g. a truncation method).

Numbers are first class objects!

Math object: some of the math functions (e.g. "min", "max", "log", "ceil", "sin") are expensive (e.g. trig functions) and you don't always need them. It would be better for math functions and math constants (e.g. PI and E) to be Number Methods, but instead JS has them has methods on the _Math Object_.

NaN: stands for "Not a Number", but has a type of "Number". Result of an undefined or erroneous operation. It's not equal to anything - not even itself! NaN === NaN is false.

"=" as the assignment operator comes from Fortran. Inherited by JS.

JS has infinity, which is a value that represents all values that are bigger than the greatest number that JS can represent.

Number.MAX_Value is the biggest number that JS knows how to represent (around 9 quadrillion).

###Strings and Arrays

Boolean: two values, true and false.

Strings: basically means "text". Crockford doesn't know why they're called "strings".
Strings are immutable --> once they are created, they cannot be modified. To "modify" them, you actually create a new string.
Similar strings are equal (under "===").
Good convention for strings: use double-quote for external strings and single-quote for internal strings and characters.

"+" operator: + can concatenate or add.

parseInt function: takes a string and a radix. e.g. parseInt(str, 10). It will stop parsing once it sees a character which is not a digit in the base that it's working in. e.g. parseInt("12em") === 12.

There are problems with leading zeroes when using parseInt. e.g. parseInt("08") === 0. We defend against this by explicitly specifying the radix (usually 10). e.g. parseInt("08", 10) === 8.

Strings have a length property. It tells you how many characters are in the string.

Strings have lots of methods (they're objects, after all). e.g. "charAt", "split", "trim", "concat".

Array: a linear sequence of memory which is divided into equal-sized buckets which can be indexed by number, which allows for a very fast way of retrieving variables from a set.

^ JS doesn't have arrays like that ^. JS arrays are actually objects. Array _inherits_ from object in JS. Indexes are converted to strings and used as names for retrieving values. One advantage is that we don't need to provide a length or type when creating an array in JS.

Arrays have a special length property. Array length is 1 larger than the highest integer subscript in the array. It allows us to use "for" loops on arrays.

Dot notation should not be used with arrays. Use bracket notation with arrays, except when calling methods.

Array methods: e.g. concat, every, filter, forEach, map, reduce, splice, some, unshift, etc.

The "sort" array method by default sorts numbers as strings, which is usually bad.

Delete operator: allows you to delete elements from an array, but leaves a hole in the array. It's better to use the "splice" method, which doesn't leave the hole - the splice method is _slow_ though.

Appending things to the end of an array tends to be fast. Removing things from anywhere, except the end of an array, tends to be very slow.